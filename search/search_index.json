{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PyKMP \u2013 a Kamstrup meter toolset","text":"<p>This module is developed for reading out Kamstrup meters using their vendor-specific KMP protocol.</p> <p>Tested with a MULTICAL\u00ae 403, based on documentation of the protocol for the older MULTICAL\u00ae models.</p> <p>Current state: alpha \u2013 based on the documentation it \"should work\" with a MULTICAL\u00ae 30x/40x/60x, but for other models: YMMV. Pull requests welcome!</p> <p>Note</p> <p>This project is not affiliated with Kamstrup A/S, Kamstrup B.V. or any other entity of the Kamstrup corporation.</p> <p>Warning: battery consumption impact</p> <p>Please be informed about the battery consumption impact, read the battery consumption page.</p> <p>Use at your own risk.</p>"},{"location":"#features","title":"Features \u2728","text":"<p>Note that this is a library, intended primarily for development or integration.</p> <ul> <li> A bundled CLI tool to interact with the meter for testing/development purposes     with JSON format output (optional).</li> <li> Read multiple registers in one go to conserve the meter's internal battery as     much as possible.</li> <li> Having it all fully type-annotated (mypy strict, zero <code>type: ignore</code>s) should     make using this library a breeze.</li> <li> 100% test coverage (library, not the tool yet).</li> <li> Ability to decode the base-10 variable length floating point values in registers     without loss of significance.</li> <li> CRC checksum verification (and adding).</li> <li> Agnostic to the direction for message encoding, ie. you could go wild and     emulate a meter using your IR optical head. \ud83e\udd13</li> </ul>"},{"location":"#license","title":"License","text":"<p>The majority of the project is Apache 2.0 licensed.</p> <p>Files deemed insignificant in terms of copyright such as configuration files are licensed under the public domain \"no rights reserved\" CC0 license.</p> <p>The repository is REUSE compliant.</p> <p>Read more on contributing in Contributing.</p>"},{"location":"battery-consumption/","title":"Battery consumption \ud83e\udeab","text":"<p>Most Kamstrup meters for heat are battery-powered. Using the optical/infrared interface will draw extra power from the battery and it may deplete sooner when using this on a regular basis.</p> <p>Extending the interval of reading should help, as well as requesting all data you need in a single request \u2013 avoid looping with just a single register ID for example.</p> <p>Reading the battery level is not (yet) possible.</p> <p>IR-circuit may only be activated with a magnet in the optical head. In addition to that, some (older) models may require periodic re-activation of the IR-circuit by pressing any button on the panel.</p>"},{"location":"contributing/","title":"Contributing","text":"<p>Your contributions, in any form, are very much welcome! \ud83d\ude4f</p> <p>When contributing to this repository with a proposed change to the code, please first discuss the change you wish to make in an issue (for bugs or features), create a discussion post in case anything is unclear, write me an email (<code>github@gertvandijk.nl</code>) or any other method with the owners of this repository before making a change.</p>"},{"location":"contributing/#getting-started-with-development","title":"Getting started with development","text":"<ol> <li> <p>Get a copy of the repository (e.g.     <code>git clone https://github.com/gertvdijk/PyKMP.git</code>) and change your current     directory in the project root.</p> </li> <li> <p>Create a clean Python 3.10.x/3.11.x/3.12.x virtual environment and activate it.     Suggested way is to install direnv together with     Pyenv and enable the project-supplied example <code>.envrc</code>.</p> <pre><code>$ ln -s .envrc-example .envrc\n$ direnv allow\n</code></pre> </li> <li> <p>Make sure the base Python packages such as <code>pip</code>, <code>setuptools</code> and <code>setuptools-scm</code>     are up-to-date inside this virtualenv.</p> <pre><code>$ pip install --upgrade pip setuptools setuptools-scm[toml]\n</code></pre> </li> <li> <p>This should list zero outdated packages at this point:</p> <pre><code>$ pip list --outdated\n</code></pre> </li> <li> <p>Install the project with development dependencies with this virtualenv active. E.g.:</p> <pre><code>$ pip install -e .[development]\n</code></pre> </li> <li> <p>Verify that all tests pass by running <code>pytest</code>.</p> <pre><code>$ pytest\n[...]\n==== 117 passed in 0.21s ====\n</code></pre> </li> <li> <p>Verify that you can run the <code>run-all-linters</code> script.</p> <pre><code>$ ./run-all-linters\n[...]\nEverything looks OK! \ud83c\udf89\n</code></pre> </li> <li> <p>You're ready to contribute your changes now!</p> </li> </ol>"},{"location":"contributing/#suggested-ide-vs-code","title":"Suggested IDE: VS Code","text":"<p>The repository ships with helpers for use with Microsoft Visual Studio Code. It suggests extensions, performs strict mypy type checking on the fly, visual indicators for code style (e.g. 88-chars ruler), provides a task with 'problemMatcher' to run the <code>run-all-linters</code> script and more.</p> <p>To get started, I suggest to open the local clone of the repository as Folder first, then save it as a Workspace afterwards. Any custom settings desired which aren't for all projects and neither should be part of this project can then be set to the workspace (local) level.</p> <p>In order for the extensions to work correctly, please select the Python interpreter of the virtualenv you created, e.g. <code>.direnv/python-3.11/bin/python</code>.</p> <p>Please set <code>ruff.importStrategy</code> to <code>fromEnvironment</code> in your workspace (or user) settings to use the same Ruff version as in the virtual environment. The Ruff plugin uses the bundled version by default.</p> <p>All linters and type checkers will run inside this environment created with specific versions specified rather than relying on whatever is available system-wide.</p> <p>Automatic on-save formatting</p> <p>If you like, enable automatic on-save formatting with project-provided settings using the user/profile-level setting <code>editor.formatOnSave</code>. It will run <code>black</code> for you whenever hitting Save on a file.</p>"},{"location":"contributing/#add-yourself-as-contributor","title":"Add yourself as contributor","text":"<p>In case you have some (significant) contributions and you would like to see your name in the copyright file headers invoke the <code>reuse</code> tool to do the job:</p> <pre><code>$ reuse annotate --copyright \"Your Name &lt;user@domain.tld&gt;\" path/to/file [file...]\n</code></pre> <p>This adds a line like below to the files specified.</p> <pre><code># SPDX-FileCopyrightText: 2023 Your Name &lt;user@domain.tld&gt;\n</code></pre> <p>Alternatively, you could choose to waive the copyright and just be mentioned as a non-copyright contributor by replacing <code>--copyright</code> with <code>--contributor</code>.</p> <p>This adds a line like below to the files specified.</p> <pre><code># SPDX-FileContributor: Your Name &lt;user@domain.tld&gt;\n</code></pre> <p>A use case for this are changes which are considered insignificant in terms of copyright, for example automated reformatting or changing the name of a variable.</p>"},{"location":"contributing/#pull-request-process","title":"Pull Request Process","text":"<p>Info</p> <p>The aim for this workflow is to end up with a clean git history which should be helpful for anyone else in the future (e.g. using git-blame, git-log).</p> <ol> <li>Fork the repository to your own GitHub account.</li> <li>Push the change(s) to your local fork, preferably to branch with a self-descriptive     name.     Please use a clean git commit history with descriptive commit messages and refer to     relevant issues or discussions.     In case your work was done in multiple iterations, use amending and/or an     interactive rebase to craft a set of contained commits.</li> <li>Ensure that your fork's branch is based off with latest upstream <code>develop</code> branch.     If not, fetch latest changes and rebase it.</li> <li>Run the <code>run-all-linters</code> script to ensure all code adheres to the code style, strict     typing requirements and licensing headers.</li> <li>Run <code>pytest</code> to ensure your code changes do not break current tests (adjust if     necessary) and your newly introduced lines are all covered by new/adjusted tests     (compare coverage output).</li> <li>All ready?!     Create a pull request targeting the <code>develop</code> branch.     Write a title that consicely describes the main aim of the changes in the request.     Consider to tick the \"Allow edits by maintainers\" checkbox (see below).</li> <li>Please allow the maintainer to take the time to review and test the code.     In case code changes are requested, please amend the commit(s) affected and update     the commit message(s) if necessary.</li> </ol> <p>Also imperfect PRs are welcome!</p> <p>If you're uncomfortable to rebase/amend or unsure about commit message wording or even adjusting test cases, please indicate that the maintainer is allowed to edit your pull request when creating the pull request.</p> <p>Then in the pull request description kindly request the maintainer to apply the work on that and consider to mark the pull request as draft.</p> <p>Notes:</p> <ul> <li> <p>Ideally, every single commit should be reversible and have a single responsibility.     Preparatory work leading up to an actual change should happen in separate commit(s)     to aid reviewing and having a useful git history.     Example of a well-crafted set of commits:</p> <p><code>HEAD   Implement feature X</code> \u2014 the aim of the pull request</p> <p><code>HEAD^  Refactor module Y to allow for subclassing ClassZ</code> \u2014 improvement, but preparatory change</p> <p><code>HEAD^^ Add tests for current logic in module Y</code> \u2014 not a functional change in itself, but purely preparatory to assert a before-change state is tested for.</p> </li> <li> <p>Please adhere to the following style in commit messages:</p> <ul> <li>Use present tense.</li> <li>Avoid captain obvious-only commit messages like \"Delete file x\" or     \"Update file y\", because, well, anyone can see precisely that when looking at     the diff.</li> <li>Add the reason for the change (if not obvious).     To have a why later looking at the changes is very useful, e.g. when creating     release notes or even at review time understanding for the need to include the     change.</li> </ul> </li> <li> <p>Please avoid merge commits in your pull request; use rebase instead.     Merge commits are harder to revert and to cherry-pick.</p> </li> <li>Pull requests should apply cleanly on the latest upstream <code>develop</code> branch.     Preferably, your branch should be 'fast-forwardable' in git-speak.</li> <li> <p>The maintainer is free to cherry-pick, amend and push your work in a pull request's     commits directly to any branch, effectively bypassing GitHub's pull request 'merge'     button.     Attributions will be preserved by either the commit's author field or a     <code>Co-authored-by</code> footer in the commits.</p> <p>This also enables to move forward with dependent commits in a pull request still pending discussion on the adoption of that actual feature or bug fix approach. E.g. the two commits at the bottom (<code>Update code style ...</code>, <code>Refactor module Y ...</code>) could be merged for everyone to profit from already and reducing the size of the pull request pending review as well.</p> </li> <li> <p>At the expense of the clean git history policy GPG/SSH signatures on commits by     contributors could be lost as a result of the amendments by non-authors.     If you wish to maintain your digitally verifiable signature, please take the time to     submit your pull request in a state it can be fast-forwarded and rebase whenever     the target branch is updated (which may be frequent).</p> </li> </ul>"},{"location":"getting-started/","title":"Getting started \ud83d\ude80","text":""},{"location":"getting-started/#installation","title":"Installation","text":"<p>First of all, you'll need Python 3.10+ (sorry, using modern Python features).</p> <p>Then just install <code>PyKMP</code> from  PyPI, e.g.:</p> <pre><code>$ python -m venv /tmp/venv       #(1)\n$ source /tmp/venv/bin/activate  #(2)\n$ pip install -U pip setuptools  #(3)\n$ pip install PyKMP[tool]        #(4)\n</code></pre> <ol> <li> <p>Creates a 'virtual environment' using the Python built-in     'venv' module.</p> </li> <li> <p>Run this every time in a new session to activate this virtual environment.</p> </li> <li> <p>Not strictly needed, but generally a good idea to update core tools like setuptools     and pip.</p> </li> <li> <p>Install with the optional dependencies for the CLI tool by adding <code>[tool]</code>.</p> </li> </ol>"},{"location":"getting-started/#cli-tool-pykmp-tool","title":"CLI tool <code>pykmp-tool</code>","text":"<p>Let's explore some of the features by using the CLI tool first.</p> <pre><code>$ source venv/bin/activate  # activate this venv in every new session\n</code></pre> Full output of <code>pykmp-tool --help</code> <pre><code>Usage: pykmp-tool [OPTIONS] COMMAND [ARGS]...\n\nCommand line tool to request data from a Kamstrup meter.\n\nOptions:\n-d, --serial-device TEXT        The path to the serial device, e.g. the USB-\n                                to-Serial converter on '/dev/ttyUSB0'. You\n                                may want to select a stable device path in\n                                '/dev/serial/by-id/' instead.\n\n                                For connecting over TCP (e.g. with ser2net),\n                                you can use 'socket://&lt;host&gt;:&lt;port&gt;'.  [env\n                                var: PYKMP_SERIAL_DEVICE; default:\n                                /dev/ttyUSB0]\n-a, --destination-address DEC_OR_HEX\n                                Data link layer destination address. (hex or\n                                int)\n\n                                The default is set to 63 (HEAT_METER). Other\n                                known addresses: 127 (LOGGER_TOP), 191\n                                (LOGGER_BASE)\n\n                                \u26a0 The tool has only been tested with the\n                                default value.  [env var:\n                                PYKMP_DESTINATION_ADDRESS; default: 63]\n-v, --verbose                   Show more logging (twice for debug logging)\n                                [default: 0]\n--help                          Show this message and exit.\n\nCommands:\nget-register  Request register(s) of the Kamstrup meter and print the...\nget-serial    Request the serial number of a Kamstrup meter and print it.\n</code></pre> <p>Retrieve some interesting metrics (registers):</p> <pre><code>$ export PYKMP_SERIAL_DEVICE=/dev/ttyUSB0  #(1)\n$ pykmp-tool get-register \\\n    --register 60 \\\n    --register 68 \\\n    --register 80 \\\n    --register 74 \\\n    --register 86 \\\n    --register 87 \\\n    --register 266\nGetRegister response(s):\n  60 \u2192 Heat Energy (E1) = 0.303 GJ\n  68 \u2192 Volume           = 11.388 m\u00b3\n  80 \u2192 Current Power    = 0.0 kW\n  74 \u2192 Flow             = 3 l/h\n  86 \u2192 Temp1            = 61.62 \u00b0C\n  87 \u2192 Temp2            = 54.02 \u00b0C\n 266 \u2192 E1HighRes        = 84208 Wh\n</code></pre> <ol> <li> <p>Totally optional, but here we use an environment variable for convenience instead of    <code>--serial-device /dev/ttyUSB0</code> in the command.     You just have to set (export) it once for the session.</p> <p> See <code>pykmp-tool --help</code> for how any other command line option can be set with environment variables.</p> </li> </ol> <p>Tip</p> <p>Add <code>--json</code> to get structured machine-readable output in JSON format.</p> <p>In case you run into issues...</p> <p><pre><code>$ pykmp-tool get-register --register 1002\nWARNING:pykmp.tool.__main__:Unknown register ID(s); please report this if you have more information.\nGetRegister response(s):\n1002 \u2192 &lt;unknown reg 1002&gt; = 200132 hh:mm:ss\n</code></pre> ... you may want to show more verbose logging and debug the communication by adding <code>-vv</code>:</p> <pre><code>$ pykmp-tool -vv get-register --register 1002\nDEBUG:pykmp.client:Request encoded: 803F100103EA4CB70D\nINFO:pykmp.client:Sending GetRegisterRequest...\nDEBUG:pykmp.client:Received bytes on serial: '403F1003EA2F040000030E33B2320D'\nDEBUG:pykmp.codec:Checksum verification OK [raw=3f1003ea2f040000030e33b232, crc_given=b232, crc_calculated=OK]\nDEBUG:pykmp.messages:Decoding register bytes. [raw='03EA2F040000030E33', length_min=6]\nDEBUG:pykmp.messages:Decoded register values: [id=1002, unit=47, value_bytes=040000030E33, remaining bytes=0]\nWARNING:pykmp.tool.__main__:Unknown register ID(s); please report this if you have more information.\nGetRegister response(s):\nDEBUG:pykmp.codec:Decoding parts of floating point data. [data='040000030E33', integer_length=4]\nDEBUG:pykmp.codec:Decoded floating point data: Decimal('200243') [data='040000030E33', man=200243, si=False, se=False, exp=0]\n1002 \u2192 &lt;unknown reg 1002&gt; = 200243 hh:mm:ss\n</code></pre> <p>Clearly, some registers appear undiscovered and the formatting for some units need some love. \ud83d\ude05</p> <p>So far we've only seen 'GetRegister' commands/responses. Another command is 'GetSerialNo':</p> <pre><code>$ pykmp-tool get-serial\nMeter serial is: 123456\n</code></pre>"},{"location":"getting-started/#api-examples","title":"API examples","text":"<p>To perform the above example with requesting the serial number, but then programmatically using the API:</p> <pre><code>from pykmp import GetSerialRequest, PySerialClientCommunicator\n\nmultical = PySerialClientCommunicator(serial_device=\"/dev/ttyUSB0\")\nresponse = multical.send_request(message=GetSerialRequest())\nprint(f\"Meter serial is: {response.serial}\")\n</code></pre> <p>And similarly, for obtaining the register data:</p> <pre><code>from pykmp import (\n    REGISTERS,\n    UNITS_NAMES,\n    FloatCodec,\n    GetRegisterRequest,\n    PySerialClientCommunicator,\n)\n\nmultical = PySerialClientCommunicator(serial_device=\"/dev/ttyUSB0\")\nresponse = multical.send_request(\n    message=GetRegisterRequest(registers=[60, 68, 74, 80, 86, 87, 89, 266])\n)\nfor reg in response.registers.values():\n    name, unit = REGISTERS.get(reg.id_, \"?\"), UNITS_NAMES.get(reg.unit, \"?\")\n    print(f\"Register {reg.id_} ({name}) data: {FloatCodec.decode(reg.value)} {unit}\")\n</code></pre>"},{"location":"hardware-requirements/","title":"Hardware requirements","text":"<p>For most situation you would want to use the optical/infrared interface. For that, you will need an IR optical read-out head with serial (or serial-to-USB) interface.</p> <p>Using Ali-Express: 'USB to optical interface IrDA near-infrared magnetic adapter' this is confirmed working with the MULTICAL\u00ae 403 (IR head positioned upside down).</p> <p>Note that a magnet is required to enable the IR circuit, but it's not strong enough to maintain the position of the head on its own. You would still want to find a way to mount the head for a permanent installation.</p>"},{"location":"resources/","title":"KMP protocol documentation","text":"<p>Technical description of meters sometimes show a little information of the design and generic specification of the protocol. This gives some clues about device-specific registers or a graphical explanation of the OSI layers. However, important details are in a separate document which is seemingly only available under NDA. \ud83d\ude22</p> <p>12.3 Data protocol</p> <p>Utilities and other relevant companies who want to develop their own communication driver for the KMP protocol can order a demonstration program in C# (.net based) as well as a detailed protocol description (in English language).</p> <p>Some more clues can be found in related communcation interfaces like MODBUS where registers are listed: Modbus/KMP TCP/IP module for MULTICAL\u00ae 603 Data sheet</p> <p>Nice people from the MeterLogger project have left some notes for the development of the MeterLogger for Kamstrup meters.</p> <p>Access to the vendor's own software to communicate with the meters ('Metertool HCW') is not available (or at least not for free).</p>"},{"location":"ser2net/","title":"Connecting over the network (ser2net)","text":"<p>It's not always practical to communicate with the meter via (USB-to-)serial. Using ser2net on a (small) device close to the meter you can expose it on your network.</p> <p>Example configuration:</p> <pre><code>connection: &amp;mykamstrup\n  accepter: tcp,2002\n  connector: &gt;-\n    serialdev,\n    /dev/serial/by-id/usb-Silicon_Labs_CP2102_USB_to_UART_Bridge_Controller_0001-if00-port0,\n    1200n82\n  options:\n    max-connections: 1\n</code></pre> <p>This above example uses TCP port 2002 on the host. A connection can be made from any other host using the <code>socket://</code> URL handler with PySerial like this:</p> <pre><code>$ pykmp-tool --serial-device socket://hostname:2002 [...]\n</code></pre> <p>Or use the environment variable to not having to specify it in every command:</p> <pre><code>$ export PYKMP_SERIAL_DEVICE=socket://hostname:2002\n</code></pre>"},{"location":"store-graph-metrics/","title":"Store and graph metrics \ud83d\udcca","text":"<p>That's not really in scope of this library, but a separate project could (should) use this.</p> <p>Anyway, it's planned to build that too! <code>&lt;img src=\"under-construction.gif\"&gt;</code></p> <p>In the meantime, you could try to automate things by getting output in JSON format using <code>--json</code>:</p> <pre><code>$ pykmp-tool get-register --json [...]\n</code></pre>"},{"location":"thanks/","title":"Thanks to... \ud83d\ude4f","text":"<p>This project's existence is mainly thanks to all the information and regarding the KMP protocol people have put online over the years.</p> <p>The MeterLogger project have left some notes for the development of the MeterLogger for Kamstrup meters. Also the work by Poul-Henning Kamp (and later Ronald van der Meer) in GitHub: <code>ronaldvdmeer/multical402-4-domoticz</code> was inspiring to get started with exploring possibilities and testing my hardware.</p> <p>Finally, also a shoutout to the Dutch community Tweakers where a forum topic pointed out the possibilities integrating these MULTICAL\u00ae meters (as provided by Dutch utilities) to non-cloud smart home. GoT: Kamstrup Multical 402 stadsverwarmingsmeter RPI3+IR-kop</p>"},{"location":"troubleshooting/","title":"Troubleshooting","text":""},{"location":"troubleshooting/#unable-to-run-the-tool-pykmp-tool-command-not-found","title":"Unable to run the tool <code>pykmp-tool: command not found</code>","text":"<p>Using a Python package manager (e.g. pip) should ensure the entry point should be installed somewhere in a directory that's on your PATH, but apparently that failed.</p> <p>As an alternative, you can try to substitute <code>pykmp-tool</code> with <code>python -m pykmp.tool</code>.</p>"},{"location":"troubleshooting/#unable-to-get-a-reading-connection-timeout","title":"Unable to get a reading (connection timeout)","text":"<ul> <li>Make sure your IR head has an included magnet that activates the meter's IR circuit.   If in doubt, activate it by pressing any button and try to get a reading while the   display is active.</li> <li>Make sure the RX/TX is aligned with the meter.   It's most if not all cases the IR head has to be placed in upside-down position.</li> <li>Try to re-align around the position of the IR optical head while keeping a command   running in a loop in your shell.</li> </ul>"},{"location":"api/","title":"API reference documentation \u2013 overview","text":""},{"location":"api/#client-module","title":"client module","text":"<p>Convenience in client communication with the KMP protocol (to meter).</p> <p>The PySerialClientCommunicator provides the most high-level class to communicate with the meter.</p> <p> <code>pykmp.client</code> module docs</p>"},{"location":"api/#messages-module","title":"messages module","text":"<p>KMP protocol application level decoding/encoding (requests and responses).</p> <p> <code>pykmp.messages</code> module docs</p>"},{"location":"api/#codec-module","title":"codec module","text":"<p>Low-level codec classes for the Kamstrup KMP protocol.</p> <p>This contains decoders/encoders for the Physical, Data Link and Application layer (generics).</p> <p>Logic for specific messages (requests and responses) are not part of this module, but generic codecs such as floating point data format encoding/decoding used in requests/responses are.</p> <p> <code>pykmp.codec</code> module docs</p>"},{"location":"api/#constants-module","title":"constants module","text":"<p>Constants/definitions for the Kamstrup KMP protocol.</p> <p> <code>pykmp.constants</code> module docs</p>"},{"location":"api/client/","title":"API reference documentation \u2013 client module","text":"<p>Convenience in client communication with the KMP protocol (to meter).</p> <p>The PySerialClientCommunicator provides the most high-level class to communicate with the meter.</p>"},{"location":"api/client/#concrete-classes","title":"Concrete classes","text":""},{"location":"api/client/#pykmp.client.ClientCodec","title":"<code>pykmp.client.ClientCodec</code>","text":"<p>Wires up the codecs of all layers for communication to the meter.</p>"},{"location":"api/client/#pykmp.client.ClientCodec.destination_address","title":"<code>destination_address: int = attrs.field(default=constants.DestinationAddress.HEAT_METER.value)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/client/#pykmp.client.ClientCodec.application_codec","title":"<code>application_codec: codec.ApplicationCodec = attrs.field(factory=codec.ApplicationCodec)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/client/#pykmp.client.ClientCodec.data_link_codec","title":"<code>data_link_codec: codec.DataLinkCodec = attrs.field(factory=codec.DataLinkCodec)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/client/#pykmp.client.ClientCodec.physical_codec_encode","title":"<code>physical_codec_encode: ClassVar = codec.PhysicalCodec(direction=codec.PhysicalDirection.TO_METER)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/client/#pykmp.client.ClientCodec.physical_codec_decode","title":"<code>physical_codec_decode: ClassVar = codec.PhysicalCodec(direction=codec.PhysicalDirection.FROM_METER)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/client/#pykmp.client.ClientCodec.encode","title":"<code>encode(request: ClientContextRequest[ClientContextResponse[CCReq_t_co]]) -&gt; EncodedClientRequest[CCReq_t_co]</code>","text":"<p>Encode a request message to bytes for sending on the physical layer.</p>"},{"location":"api/client/#pykmp.client.ClientCodec.decode","title":"<code>decode(*, frame: EncodedClientResponse[ClientContextRequest[CCResp_t_co]]) -&gt; CCResp_t_co</code>","text":"<p>Decode bytes from the physical layer to a response message.</p>"},{"location":"api/client/#pykmp.client.PySerialClientCommunicator","title":"<code>pykmp.client.PySerialClientCommunicator</code>","text":"<p>             Bases: <code>ClientCommunicator</code></p> <p>Uses PySerial to connect, read and write to a meter.</p> <p>For connecting over TCP (e.g. with ser2net) use 'socket://:' as 'serial_device' string."},{"location":"api/client/#pykmp.client.PySerialClientCommunicator.DEFAULT_READ_TIMEOUT_SECONDS","title":"<code>DEFAULT_READ_TIMEOUT_SECONDS: float = 2.0</code>  <code>class-attribute</code>","text":""},{"location":"api/client/#pykmp.client.PySerialClientCommunicator.serial_device","title":"<code>serial_device: str = attrs.field()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/client/#pykmp.client.PySerialClientCommunicator.timeout_seconds","title":"<code>timeout_seconds: float = attrs.field(default=DEFAULT_READ_TIMEOUT_SECONDS)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/client/#pykmp.client.PySerialClientCommunicator.send_request","title":"<code>send_request(*, message: ClientContextRequest[CCResp_t_co], destination_address: int = DESTINATION_ADDRESS_DEFAULT) -&gt; CCResp_t_co</code>","text":"<p>Encode and send a request, return decoded response.</p>"},{"location":"api/client/#pykmp.client.PySerialClientCommunicator.__attrs_post_init__","title":"<code>__attrs_post_init__() -&gt; None</code>","text":"<p>Initialize a serial.Serial object in self._serial.</p>"},{"location":"api/client/#pykmp.client.PySerialClientCommunicator.read","title":"<code>read(*, num_bytes: int | None = None) -&gt; codec.PhysicalBytes</code>","text":"<p>Read from serial device or network socket.</p> <p>If num_bytes is provided, it reads num_bytes number of bytes, else it will read until stop byte.</p>"},{"location":"api/client/#pykmp.client.PySerialClientCommunicator.read_num_bytes","title":"<code>read_num_bytes(num_bytes: int) -&gt; codec.PhysicalBytes</code>","text":"<p>Read num_bytes number of bytes from serial device or network socket.</p>"},{"location":"api/client/#pykmp.client.PySerialClientCommunicator.read_until_stop","title":"<code>read_until_stop() -&gt; codec.PhysicalBytes</code>","text":"<p>Read bytes from serial device or network socket until a stop byte.</p>"},{"location":"api/client/#pykmp.client.PySerialClientCommunicator.write","title":"<code>write(data: codec.PhysicalBytes) -&gt; None</code>","text":"<p>Write the bytes to the serial device or network socket.</p>"},{"location":"api/client/#constants","title":"Constants","text":""},{"location":"api/client/#pykmp.client.DESTINATION_ADDRESS_DEFAULT","title":"<code>pykmp.client.DESTINATION_ADDRESS_DEFAULT = attrs.fields(ClientCodec).destination_address.default</code>  <code>module-attribute</code>","text":""},{"location":"api/client/#pykmp.client.PYSERIAL_AVAILABLE","title":"<code>pykmp.client.PYSERIAL_AVAILABLE = bool(importlib.util.find_spec('serial'))</code>  <code>module-attribute</code>","text":""},{"location":"api/client/#data-classes-types","title":"Data classes &amp; types","text":""},{"location":"api/client/#pykmp.client.CCReq_t_co","title":"<code>pykmp.client.CCReq_t_co = TypeVar('CCReq_t_co', bound='ClientContextRequest[Any]', covariant=True)</code>  <code>module-attribute</code>","text":""},{"location":"api/client/#pykmp.client.CCResp_t_co","title":"<code>pykmp.client.CCResp_t_co = TypeVar('CCResp_t_co', bound='ClientContextResponse[Any]', covariant=True)</code>  <code>module-attribute</code>","text":""},{"location":"api/client/#pykmp.client.ClientContextRequest","title":"<code>pykmp.client.ClientContextRequest</code>","text":"<p>             Bases: <code>SupportsEncode</code>, <code>BaseRequest[CCResp_t_co]</code>, <code>Protocol[CCResp_t_co]</code></p> <p>Generic request KMP message type that can be used in a client context.</p>"},{"location":"api/client/#pykmp.client.ClientContextResponse","title":"<code>pykmp.client.ClientContextResponse</code>","text":"<p>             Bases: <code>SupportsDecode</code>, <code>BaseResponse[CCReq_t_co]</code>, <code>Protocol[CCReq_t_co]</code></p> <p>Generic response KMP message type that can be used in a client context.</p>"},{"location":"api/client/#pykmp.client.EncodedClientRequest","title":"<code>pykmp.client.EncodedClientRequest</code>","text":"<p>             Bases: <code>Generic[CCReq_t_co]</code></p> <p>Wraps the physical bytes type to include request type information.</p>"},{"location":"api/client/#pykmp.client.EncodedClientRequest.physical_bytes","title":"<code>physical_bytes: codec.PhysicalBytes</code>  <code>instance-attribute</code>","text":""},{"location":"api/client/#pykmp.client.EncodedClientRequest.request_cls","title":"<code>request_cls: type[ClientContextRequest[ClientContextResponse[CCReq_t_co]]]</code>  <code>instance-attribute</code>","text":""},{"location":"api/client/#pykmp.client.EncodedClientResponse","title":"<code>pykmp.client.EncodedClientResponse</code>","text":"<p>             Bases: <code>Generic[CCReq_t_co]</code></p> <p>Wraps the physical bytes type to include request (response) type information.</p>"},{"location":"api/client/#pykmp.client.EncodedClientResponse.physical_bytes","title":"<code>physical_bytes: codec.PhysicalBytes</code>  <code>instance-attribute</code>","text":""},{"location":"api/client/#pykmp.client.EncodedClientResponse.request_cls","title":"<code>request_cls: type[CCReq_t_co]</code>  <code>instance-attribute</code>","text":""},{"location":"api/client/#base-classes","title":"Base classes","text":""},{"location":"api/client/#pykmp.client.ClientCommunicator","title":"<code>pykmp.client.ClientCommunicator</code>","text":"<p>             Bases: <code>Protocol</code></p> <p>Wrap the codecs and communication communication with the meter.</p>"},{"location":"api/client/#pykmp.client.ClientCommunicator.read","title":"<code>read(*, num_bytes: int | None = None) -&gt; codec.PhysicalBytes</code>","text":"<p>Read num_bytes number of bytes (or until stop byte if None) from [...].</p> <p>If num_bytes is provided, it reads num_bytes number of bytes, else it will read until stop byte.</p>"},{"location":"api/client/#pykmp.client.ClientCommunicator.write","title":"<code>write(data: codec.PhysicalBytes) -&gt; None</code>","text":"<p>Write the bytes to [...].</p>"},{"location":"api/client/#pykmp.client.ClientCommunicator.send_request","title":"<code>send_request(*, message: ClientContextRequest[CCResp_t_co], destination_address: int = DESTINATION_ADDRESS_DEFAULT) -&gt; CCResp_t_co</code>","text":"<p>Encode and send a request, return decoded response.</p>"},{"location":"api/codec/","title":"API reference documentation \u2013 codec module","text":"<p>Low-level codec classes for the Kamstrup KMP protocol.</p> <p>This contains decoders/encoders for the Physical, Data Link and Application layer (generics).</p> <p>Logic for specific messages (requests and responses) are not part of this module, but generic codecs such as floating point data format encoding/decoding used in requests/responses are.</p>"},{"location":"api/codec/#concrete-classes","title":"Concrete classes","text":""},{"location":"api/codec/#pykmp.codec.PhysicalCodec","title":"<code>pykmp.codec.PhysicalCodec</code>","text":"<p>Codec for the physical layer of the Kamstrup KMP protocol.</p> <p>This codec is responsible for encoding/decoding a frame to/from the data link layer message for writing/reading to/from the IR head. What it does is:</p> <ul> <li>Adding/removing start/stop bytes.</li> <li>Stuffing/destuffing some special byte values.</li> </ul> <p>Note that the codec is slightly different for sending or receiving messages to/from the meter.</p> <p>See section 3.1 of the KMP protocol description document.</p>"},{"location":"api/codec/#pykmp.codec.PhysicalCodec.direction","title":"<code>direction: PhysicalDirection = attrs.field()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/codec/#pykmp.codec.PhysicalCodec.BYTE_STUFFING_MAP","title":"<code>BYTE_STUFFING_MAP: Final[dict[bytes, bytes]] = {the_byte.to_bytes(1, 'big'): constants.ByteCode.STUFFING.value.to_bytes(1, 'big') + the_byte ^ 255.to_bytes(1, 'big')for the_byte in (constants.ByteCode.STUFFING.value, constants.ByteCode.ACK.value, constants.ByteCode.START_FROM_METER.value, constants.ByteCode.START_TO_METER.value, constants.ByteCode.STOP.value)}</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/codec/#pykmp.codec.PhysicalCodec.__attrs_post_init__","title":"<code>__attrs_post_init__() -&gt; None</code>","text":"<p>Select start byte value according to configuration (direction).</p>"},{"location":"api/codec/#pykmp.codec.PhysicalCodec.decode","title":"<code>decode(frame: PhysicalBytes) -&gt; DataLinkBytes</code>","text":"<p>Decode a byte sequence of the physical layer into 'DataLinkBytes'.</p> <p>The <code>frame</code> must start with a start byte and ends with an end byte, unless it's an ACK frame.</p>"},{"location":"api/codec/#pykmp.codec.PhysicalCodec.encode","title":"<code>encode(data_bytes: DataLinkBytes) -&gt; PhysicalBytes</code>","text":"<p>Encode a byte sequence of the data link layer into 'PhysicalBytes'.</p> <p>This 'stuffs' the special byte values and adds start/stop bytes.</p> <p>For encoding an ACK message, see encode_ack().</p>"},{"location":"api/codec/#pykmp.codec.PhysicalCodec.encode_ack","title":"<code>encode_ack() -&gt; PhysicalBytes</code>  <code>classmethod</code>","text":"<p>Encode an ACK message.</p> <p>This type of message does not need andy stuffing or start/stop bytes.</p>"},{"location":"api/codec/#pykmp.codec.DataLinkCodec","title":"<code>pykmp.codec.DataLinkCodec</code>","text":"<p>Codec for the data link layer of the Kamstrup KMP protocol.</p> <p>This codec is responsible for encoding/decoding to/from the application layer messages. What it does is:</p> <ul> <li>Destructuring the byte sequence into a destination address, application layer byte   sequence and a CRC checksum.</li> <li>CRC checksum calculation/verification.</li> </ul> <p>See section 3.2 of the KMP protocol description document.</p>"},{"location":"api/codec/#pykmp.codec.DataLinkCodec.DATA_LINK_BYTES_LENGTH_MIN","title":"<code>DATA_LINK_BYTES_LENGTH_MIN: Final[int] = 4</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/codec/#pykmp.codec.DataLinkCodec.APPLICATION_BYTES_LENGTH_MIN","title":"<code>APPLICATION_BYTES_LENGTH_MIN: Final[int] = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/codec/#pykmp.codec.DataLinkCodec.crc_calculator","title":"<code>crc_calculator: Final[crc.Calculator] = _create_kamstrup_crc16_ccitt_calculator()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/codec/#pykmp.codec.DataLinkCodec.decode","title":"<code>decode(raw: DataLinkBytes) -&gt; DataLinkData</code>","text":"<p>Decode a byte sequence of the data link layer into 'DataLinkData'.</p> <p>This destructures it into the destination address, the application data and the CRC checksum. Also the latter will be verified.</p>"},{"location":"api/codec/#pykmp.codec.DataLinkCodec.encode","title":"<code>encode(data: DataLinkData) -&gt; DataLinkBytes</code>","text":"<p>Encode a byte sequence of the application layer into 'DataLinkBytes'.</p> <p>The structure includes the destination address and a CRC checksum (calculated here).</p>"},{"location":"api/codec/#pykmp.codec.ApplicationCodec","title":"<code>pykmp.codec.ApplicationCodec</code>","text":"<p>Codec for the application layer of the Kamstrup KMP protocol.</p> <p>This codec is responsible for encoding/decoding to/from the command data byte sequences. What it does is destructuring the byte sequence into a Command ID (CID) and the command data.</p> <p>Note that this covers both requests and responses and command data may be emtpy.</p> <p>See section 3.3 of the KMP protocol description document.</p>"},{"location":"api/codec/#pykmp.codec.ApplicationCodec.APPLICATION_BYTES_LENGTH_MIN","title":"<code>APPLICATION_BYTES_LENGTH_MIN: Final[int] = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/codec/#pykmp.codec.ApplicationCodec.decode","title":"<code>decode(data: ApplicationBytes) -&gt; ApplicationData</code>  <code>classmethod</code>","text":"<p>Decode a byte sequence of the application layer into 'ApplicationData'.</p>"},{"location":"api/codec/#pykmp.codec.ApplicationCodec.encode","title":"<code>encode(to_encode: ApplicationData) -&gt; ApplicationBytes</code>  <code>classmethod</code>","text":"<p>Encode to a byte sequence of the application layer 'ApplicationBytes'.</p>"},{"location":"api/codec/#pykmp.codec.FloatCodec","title":"<code>pykmp.codec.FloatCodec</code>","text":"<p>Codec for the variable length base-10 floating point format in the KMP protocol.</p> <p>The length of the mantissa is encoded and is commonly 32 bits (4 bytes). A visual representation of the format using an example:</p> <pre><code>data: 0x024300FB\n\n    0x02     0x43     0x00     0xFB (hex)\n00000010 01000011 00000000 11111011 (bin)\n\n00000010 ________ ________ ________ &lt;- length of significand\n________ 0_______ ________ ________ &lt;- sign bit for significand 'SI' (1=negative)\n________ _1______ ________ ________ &lt;- sign bit for exponent 'SE'\n________ __000011 ________ ________ &lt;- 6 exponent bits\n________ ________ 00000000 11111011 &lt;- significand (int) 'mantissa'\n</code></pre> <p>In the above example: - 0x02 decodes to a length of 2 bytes = 16 bits to read for the mantissa. - SI=0, so a positive value. - SE=1, thus a negative exponent. - exponent=0x03 = 3 (decimal) - mantissa=0x00FB = 251 (decimal)</p> <p>Calculation with the above example data:</p> <pre><code>    -1|1 * (mantissa * 10 ^ ( -1|1   * exponent )\n\n      1  * (  251    * 10 ^ (  -1    *    3     ) = 0.251\n</code></pre> <p>In short, The mantissa holds the significands of the data, the others are just for scale.</p> <p>See also section 4.2 of the KMP protocol description document.</p>"},{"location":"api/codec/#pykmp.codec.FloatCodec.decode","title":"<code>decode(data: bytes) -&gt; decimal.Decimal</code>  <code>classmethod</code>","text":"<p>Decode a byte sequence of a floating point format to a decimal.Decimal.</p>"},{"location":"api/codec/#pykmp.codec.FloatCodec.decode_int_or_float","title":"<code>decode_int_or_float(data: bytes) -&gt; int | float</code>  <code>classmethod</code>","text":"<p>Decode a KMP protocol byte sequence of a floating point as int or float.</p> <p>Returns an int if it can be encoded as a int (\"nothing after the comma\") to avoid losing significance.</p> <p>This implements an alternative way to decoding the base-10 floating point. It is included for reference/testing. It may be slow or one may be unfamiliar with Python's decimal.Decimal types. Note that you may lose significance in this conversion to float, or some infamous floating point error like '63.440000000000005' instead of '63.44'.</p> <p>Its use is discouraged and if one needs a float then convert the returned decimal.Decimal from the regular <code>decode()</code> method.</p>"},{"location":"api/codec/#pykmp.codec.FloatCodec.encode","title":"<code>encode(*, to_encode: decimal.Decimal, significand_num_bytes: int | None = 4) -&gt; bytes</code>  <code>classmethod</code>","text":"<p>Encode a decimal.Decimal value to a byte sequence in the KMP protocol.</p>"},{"location":"api/codec/#data-classes-types","title":"Data classes &amp; types","text":""},{"location":"api/codec/#pykmp.codec.PhysicalBytes","title":"<code>pykmp.codec.PhysicalBytes = NewType('PhysicalBytes', bytes)</code>  <code>module-attribute</code>","text":"<p>Distinct type (bytes) representing serialized bytes on the physical layer.</p>"},{"location":"api/codec/#pykmp.codec.DataLinkBytes","title":"<code>pykmp.codec.DataLinkBytes = NewType('DataLinkBytes', bytes)</code>  <code>module-attribute</code>","text":"<p>Distinct type (bytes) representing serialized bytes on the data link layer.</p>"},{"location":"api/codec/#pykmp.codec.ApplicationBytes","title":"<code>pykmp.codec.ApplicationBytes = NewType('ApplicationBytes', bytes)</code>  <code>module-attribute</code>","text":"<p>Distinct type (bytes) representing serialized data on the application layer.</p>"},{"location":"api/codec/#pykmp.codec.ApplicationDataBytes","title":"<code>pykmp.codec.ApplicationDataBytes = NewType('ApplicationDataBytes', bytes)</code>  <code>module-attribute</code>","text":"<p>Distinct type (bytes) representing serialized application (message) data.</p>"},{"location":"api/codec/#pykmp.codec.ApplicationData","title":"<code>pykmp.codec.ApplicationData</code>","text":"<p>Data class for the data in the application layer of the Kamstrup KMP protocol.</p>"},{"location":"api/codec/#pykmp.codec.ApplicationData.command_id","title":"<code>command_id: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/codec/#pykmp.codec.ApplicationData.data","title":"<code>data: ApplicationDataBytes</code>  <code>instance-attribute</code>","text":""},{"location":"api/codec/#pykmp.codec.DataLinkData","title":"<code>pykmp.codec.DataLinkData</code>","text":"<p>Data class for the data in the data link layer of the Kamstrup KMP protocol.</p>"},{"location":"api/codec/#pykmp.codec.DataLinkData.destination_address","title":"<code>destination_address: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/codec/#pykmp.codec.DataLinkData.application_bytes","title":"<code>application_bytes: ApplicationBytes</code>  <code>instance-attribute</code>","text":""},{"location":"api/codec/#pykmp.codec.DataLinkData.crc_value","title":"<code>crc_value: int | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/codec/#pykmp.codec.PhysicalDirection","title":"<code>pykmp.codec.PhysicalDirection</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Specifies the direction of communication for the Kamstrup KMP protocol.</p>"},{"location":"api/codec/#pykmp.codec.PhysicalDirection.TO_METER","title":"<code>TO_METER = enum.auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/codec/#pykmp.codec.PhysicalDirection.FROM_METER","title":"<code>FROM_METER = enum.auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/codec/#exceptions","title":"Exceptions","text":""},{"location":"api/codec/#pykmp.codec.AckReceivedException","title":"<code>pykmp.codec.AckReceivedException</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Not an error; it was just an ACK and no data link bytes to return.</p>"},{"location":"api/codec/#pykmp.codec.BaseCodecError","title":"<code>pykmp.codec.BaseCodecError</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Base error for anything that originates from logic here.</p>"},{"location":"api/codec/#pykmp.codec.OutOfRangeError","title":"<code>pykmp.codec.OutOfRangeError</code>","text":"<p>             Bases: <code>BaseCodecError</code></p> <p>A value was found outside of a valid range.</p> <p>Supports ranges with both lower and upper bounds, only upper and only lower. Range is inclusive.</p>"},{"location":"api/codec/#pykmp.codec.OutOfRangeError.what","title":"<code>what: str</code>  <code>instance-attribute</code>","text":""},{"location":"api/codec/#pykmp.codec.OutOfRangeError.valid_range","title":"<code>valid_range: tuple[int, int] | tuple[int, None] | tuple[None, int]</code>  <code>instance-attribute</code>","text":""},{"location":"api/codec/#pykmp.codec.OutOfRangeError.actual","title":"<code>actual: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/codec/#pykmp.codec.OutOfRangeError.__str__","title":"<code>__str__() -&gt; str</code>","text":""},{"location":"api/codec/#pykmp.codec.DataLengthUnexpectedError","title":"<code>pykmp.codec.DataLengthUnexpectedError</code>","text":"<p>             Bases: <code>BaseCodecError</code></p>"},{"location":"api/codec/#pykmp.codec.DataLengthUnexpectedError.what","title":"<code>what: str</code>  <code>instance-attribute</code>","text":""},{"location":"api/codec/#pykmp.codec.DataLengthUnexpectedError.actual","title":"<code>actual: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/codec/#pykmp.codec.DataLengthUnexpectedError.length_expected","title":"<code>length_expected: int | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/codec/#pykmp.codec.DataLengthUnexpectedError.expected_is_minimum","title":"<code>expected_is_minimum: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/codec/#pykmp.codec.DataLengthUnexpectedError.__str__","title":"<code>__str__() -&gt; str</code>","text":""},{"location":"api/codec/#pykmp.codec.BoundaryByteInvalidError","title":"<code>pykmp.codec.BoundaryByteInvalidError</code>","text":"<p>             Bases: <code>BaseCodecError</code></p> <p>First or last byte is not a start or stop byte respectively.</p>"},{"location":"api/codec/#pykmp.codec.BoundaryByteInvalidError.what","title":"<code>what: Literal['start', 'stop']</code>  <code>instance-attribute</code>","text":""},{"location":"api/codec/#pykmp.codec.BoundaryByteInvalidError.expected_byte","title":"<code>expected_byte: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/codec/#pykmp.codec.BoundaryByteInvalidError.actual_byte","title":"<code>actual_byte: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/codec/#pykmp.codec.BoundaryByteInvalidError.__str__","title":"<code>__str__() -&gt; str</code>","text":""},{"location":"api/codec/#pykmp.codec.InvalidDestinationAddressError","title":"<code>pykmp.codec.InvalidDestinationAddressError</code>","text":"<p>             Bases: <code>BaseCodecError</code></p> <p>Destination address for the data link layer is not within valid range.</p>"},{"location":"api/codec/#pykmp.codec.InvalidDestinationAddressError.__str__","title":"<code>__str__() -&gt; str</code>","text":""},{"location":"api/codec/#pykmp.codec.UnsupportedDecimalExponentError","title":"<code>pykmp.codec.UnsupportedDecimalExponentError</code>","text":"<p>             Bases: <code>BaseCodecError</code></p> <p>The Decimal value cannot be encoded to a base-10 float (non-integer exponent).</p>"},{"location":"api/codec/#pykmp.codec.UnsupportedDecimalExponentError.actual_exponent","title":"<code>actual_exponent: Any</code>  <code>instance-attribute</code>","text":""},{"location":"api/codec/#pykmp.codec.UnsupportedDecimalExponentError.__str__","title":"<code>__str__() -&gt; str</code>","text":""},{"location":"api/codec/#pykmp.codec.CrcChecksumInvalidError","title":"<code>pykmp.codec.CrcChecksumInvalidError</code>","text":"<p>             Bases: <code>BaseCodecError</code></p> <p>CRC checksum validation of the data link byte sequence did not pass.</p>"},{"location":"api/constants/","title":"API reference documentation \u2013 constants module","text":"<p>Constants/definitions for the Kamstrup KMP protocol.</p>"},{"location":"api/constants/#constants","title":"Constants","text":""},{"location":"api/constants/#pykmp.constants.REGISTERS","title":"<code>pykmp.constants.REGISTERS: Final[Mapping[int, str]] = {60: 'Heat Energy (E1)', 68: 'Volume', 74: 'Flow', 80: 'Current Power', 86: 'Temp1', 87: 'Temp2', 89: 'Tempdiff', 97: 'Temp1xm3', 110: 'Temp2xm3', 113: 'Infoevent', 123: 'MaxFlowDate_Y', 124: 'MaxFlow_Y', 125: 'MinFlowDate_Y', 126: 'MinFlow_Y', 127: 'MaxPowerDate_Y', 128: 'MaxPower_Y', 129: 'MinPowerDate_Y', 130: 'MinPower_Y', 138: 'MaxFlowDate_M', 139: 'MaxFlow_M', 140: 'MinFlowDate_M', 141: 'MinFlow_M', 142: 'MaxPowerDate_M', 143: 'MaxPower_M', 144: 'MinPowerDate_M', 145: 'MinPower_M', 146: 'AvgTemp1_Y', 147: 'AvgTemp2_Y', 149: 'AvgTemp1_M', 150: 'AvgTemp2_M', 266: 'E1HighRes', 1004: 'HourCounter'}</code>  <code>module-attribute</code>","text":""},{"location":"api/constants/#pykmp.constants.UNITS_NAMES","title":"<code>pykmp.constants.UNITS_NAMES: Final[Mapping[int, str]] = {0: 'no unit (number)', 1: 'Wh', 2: 'kWh', 3: 'MWh', 4: 'GWh', 5: 'J', 6: 'kJ', 7: 'MJ', 8: 'GJ', 9: 'Cal', 10: 'kCal', 11: 'Mcal', 12: 'Gcal', 13: 'varh', 14: 'kvarh', 15: 'Mvarh', 16: 'Gvarh', 17: 'VAh', 18: 'kVAh', 19: 'MVAh', 20: 'GVAh', 21: 'kW', 22: 'kW', 23: 'MW', 24: 'GW', 25: 'kvar', 26: 'kvar', 27: 'Mvar', 28: 'Gvar', 29: 'VA', 30: 'kVA', 31: 'MVA', 32: 'GVA', 33: 'V', 34: 'A', 35: 'kV', 36: 'kA', 37: '\u00b0C', 38: '\u00b0K', 39: 'l', 40: 'm\u00b3', 41: 'l/h', 42: 'm\u00b3/h', 43: 'm\u00b3\u00d7C', 44: 'ton', 45: 'ton/h', 46: 'h', 47: 'hh:mm:ss', 48: 'yy:mm:dd', 49: 'yyyy:mm:dd', 50: 'mm:dd', 51: 'no unit (number)', 52: 'bar', 53: 'RTC', 54: 'ASCII', 55: 'm\u00b3 \u00d710', 56: 'ton \u00d710', 57: 'GJ \u00d710', 58: 'minutes', 59: 'Bitfield', 60: 's', 61: 'ms', 62: 'days', 63: 'RTC-Q', 64: 'Datetime'}</code>  <code>module-attribute</code>","text":""},{"location":"api/constants/#pykmp.constants.ACK_BYTES","title":"<code>pykmp.constants.ACK_BYTES: Final[bytes] = ByteCode.ACK.value.to_bytes(1, 'big')</code>  <code>module-attribute</code>","text":""},{"location":"api/constants/#data-classes-types","title":"Data classes &amp; types","text":""},{"location":"api/constants/#pykmp.constants.ByteCode","title":"<code>pykmp.constants.ByteCode</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Special byte values on the physical layer.</p>"},{"location":"api/constants/#pykmp.constants.ByteCode.START_FROM_METER","title":"<code>START_FROM_METER = 64</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/constants/#pykmp.constants.ByteCode.START_TO_METER","title":"<code>START_TO_METER = 128</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/constants/#pykmp.constants.ByteCode.STOP","title":"<code>STOP = 13</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/constants/#pykmp.constants.ByteCode.ACK","title":"<code>ACK = 6</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/constants/#pykmp.constants.ByteCode.STUFFING","title":"<code>STUFFING = 27</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/constants/#pykmp.constants.DestinationAddress","title":"<code>pykmp.constants.DestinationAddress</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Data link layer address.</p>"},{"location":"api/constants/#pykmp.constants.DestinationAddress.HEAT_METER","title":"<code>HEAT_METER = 63</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/constants/#pykmp.constants.DestinationAddress.LOGGER_TOP","title":"<code>LOGGER_TOP = 127</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/constants/#pykmp.constants.DestinationAddress.LOGGER_BASE","title":"<code>LOGGER_BASE = 191</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/constants/#pykmp.constants.CommandId","title":"<code>pykmp.constants.CommandId</code>","text":"<p>             Bases: <code>Enum</code></p> <p>CID values for messages.</p>"},{"location":"api/constants/#pykmp.constants.CommandId.GET_TYPE","title":"<code>GET_TYPE = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/constants/#pykmp.constants.CommandId.GET_SERIAL","title":"<code>GET_SERIAL = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/constants/#pykmp.constants.CommandId.SET_CLOCK","title":"<code>SET_CLOCK = 9</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/constants/#pykmp.constants.CommandId.GET_REGISTER","title":"<code>GET_REGISTER = 16</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/constants/#pykmp.constants.CommandId.PUT_REGISTER","title":"<code>PUT_REGISTER = 17</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/constants/#pykmp.constants.CommandId.GET_EVENT_STATUS","title":"<code>GET_EVENT_STATUS = 155</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/constants/#pykmp.constants.CommandId.CLEAR_EVENT_STATUS","title":"<code>CLEAR_EVENT_STATUS = 156</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/constants/#pykmp.constants.CommandId.GET_LOG_TIME_PRESENT","title":"<code>GET_LOG_TIME_PRESENT = 160</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/constants/#pykmp.constants.CommandId.GET_LOG_PAST_PRESENT","title":"<code>GET_LOG_PAST_PRESENT = 161</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/constants/#pykmp.constants.CommandId.GET_LOG_ID_PRESENT","title":"<code>GET_LOG_ID_PRESENT = 162</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/constants/#pykmp.constants.CommandId.GET_LOG_TIME_PAST","title":"<code>GET_LOG_TIME_PAST = 163</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/messages/","title":"API reference documentation \u2013 messages module","text":"<p>KMP protocol application level decoding/encoding (requests and responses).</p>"},{"location":"api/messages/#concrete-message-types","title":"Concrete message types","text":""},{"location":"api/messages/#pykmp.messages.GetTypeRequest","title":"<code>pykmp.messages.GetTypeRequest</code>","text":"<p>             Bases: <code>BaseRequest['GetTypeResponse']</code>, <code>WithoutDataMixin</code></p> <p>Request the meter type and software revision.</p>"},{"location":"api/messages/#pykmp.messages.GetTypeRequest.response_type","title":"<code>response_type: type[GetTypeResponse]</code>  <code>class-attribute</code>","text":""},{"location":"api/messages/#pykmp.messages.GetTypeRequest.command_id","title":"<code>command_id: int = constants.CommandId.GET_TYPE.value</code>  <code>class-attribute</code>","text":""},{"location":"api/messages/#pykmp.messages.GetTypeRequest.command_name","title":"<code>command_name: str = 'GetType'</code>  <code>class-attribute</code>","text":""},{"location":"api/messages/#pykmp.messages.GetTypeRequest.get_response_type","title":"<code>get_response_type() -&gt; type[Res_t_co]</code>  <code>classmethod</code>","text":"<p>Return the response class (type) matching this request class.</p>"},{"location":"api/messages/#pykmp.messages.GetTypeRequest.decode","title":"<code>decode(data: codec.ApplicationData) -&gt; Self</code>  <code>classmethod</code>","text":"<p>Decode the message (command ID only, no data expected for this message).</p>"},{"location":"api/messages/#pykmp.messages.GetTypeRequest.encode","title":"<code>encode() -&gt; codec.ApplicationData</code>","text":"<p>Encode the message (command ID only, no data expected for this message).</p>"},{"location":"api/messages/#pykmp.messages.GetTypeResponse","title":"<code>pykmp.messages.GetTypeResponse</code>","text":"<p>             Bases: <code>BaseResponse[GetTypeRequest]</code>, <code>WithDataMixin</code>, <code>SupportsDecode</code>, <code>SupportsEncode</code></p> <p>Response with the meter type and its software revision.</p>"},{"location":"api/messages/#pykmp.messages.GetTypeResponse.data_raw","title":"<code>data_raw: codec.ApplicationDataBytes | None = attrs.field(default=None)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/messages/#pykmp.messages.GetTypeResponse.request_type","title":"<code>request_type: type = GetTypeRequest</code>  <code>class-attribute</code>","text":""},{"location":"api/messages/#pykmp.messages.GetTypeResponse.command_id","title":"<code>command_id: int = GetTypeRequest.command_id</code>  <code>class-attribute</code>","text":""},{"location":"api/messages/#pykmp.messages.GetTypeResponse.command_name","title":"<code>command_name: str = GetTypeRequest.command_name</code>  <code>class-attribute</code>","text":""},{"location":"api/messages/#pykmp.messages.GetTypeResponse.meter_type_bytes","title":"<code>meter_type_bytes: bytes = attrs.field()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/messages/#pykmp.messages.GetTypeResponse.software_revision","title":"<code>software_revision: str | None = attrs.field()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/messages/#pykmp.messages.GetTypeResponse.METER_TYPE_LENGTH_ENCODED","title":"<code>METER_TYPE_LENGTH_ENCODED: int = 2</code>  <code>class-attribute</code>","text":""},{"location":"api/messages/#pykmp.messages.GetTypeResponse.SOFTWARE_REVISION_LENGTH_ENCODED","title":"<code>SOFTWARE_REVISION_LENGTH_ENCODED: int = 2</code>  <code>class-attribute</code>","text":""},{"location":"api/messages/#pykmp.messages.GetTypeResponse.SOFTWARE_REVISION_LETTER_INT_MIN","title":"<code>SOFTWARE_REVISION_LETTER_INT_MIN: int = 1</code>  <code>class-attribute</code>","text":""},{"location":"api/messages/#pykmp.messages.GetTypeResponse.SOFTWARE_REVISION_LETTER_INT_MAX","title":"<code>SOFTWARE_REVISION_LETTER_INT_MAX: int = 26</code>  <code>class-attribute</code>","text":""},{"location":"api/messages/#pykmp.messages.GetTypeResponse.SOFTWARE_REVISION_STR_RE","title":"<code>SOFTWARE_REVISION_STR_RE: re.Pattern[str] = re.compile(f'^(?P&lt;letter&gt;[A-Z])(?P&lt;number&gt;{ZERO_TO_255_RE.pattern})$', re.VERBOSE)</code>  <code>class-attribute</code>","text":""},{"location":"api/messages/#pykmp.messages.GetTypeResponse.SOFTWARE_REVISION_UNAVAILABLE_BYTES","title":"<code>SOFTWARE_REVISION_UNAVAILABLE_BYTES: bytes = b'\\x00\\x00'</code>  <code>class-attribute</code>","text":""},{"location":"api/messages/#pykmp.messages.GetTypeResponse.get_request_type","title":"<code>get_request_type() -&gt; type[Req_t_co]</code>  <code>classmethod</code>","text":"<p>Return the request class (type) matching this response class.</p>"},{"location":"api/messages/#pykmp.messages.GetTypeResponse.decode","title":"<code>decode(data: codec.ApplicationData) -&gt; Self</code>  <code>classmethod</code>","text":"<p>Decode GetType response.</p>"},{"location":"api/messages/#pykmp.messages.GetTypeResponse.encode","title":"<code>encode() -&gt; codec.ApplicationData</code>","text":"<p>Encode GetType response.</p>"},{"location":"api/messages/#pykmp.messages.GetSerialRequest","title":"<code>pykmp.messages.GetSerialRequest</code>","text":"<p>             Bases: <code>BaseRequest['GetSerialResponse']</code>, <code>WithoutDataMixin</code></p> <p>Request the meter's serial number.</p>"},{"location":"api/messages/#pykmp.messages.GetSerialRequest.response_type","title":"<code>response_type: type[GetSerialResponse]</code>  <code>class-attribute</code>","text":""},{"location":"api/messages/#pykmp.messages.GetSerialRequest.command_id","title":"<code>command_id: int = constants.CommandId.GET_SERIAL.value</code>  <code>class-attribute</code>","text":""},{"location":"api/messages/#pykmp.messages.GetSerialRequest.command_name","title":"<code>command_name: str = 'GetSerialNo'</code>  <code>class-attribute</code>","text":""},{"location":"api/messages/#pykmp.messages.GetSerialRequest.get_response_type","title":"<code>get_response_type() -&gt; type[Res_t_co]</code>  <code>classmethod</code>","text":"<p>Return the response class (type) matching this request class.</p>"},{"location":"api/messages/#pykmp.messages.GetSerialRequest.decode","title":"<code>decode(data: codec.ApplicationData) -&gt; Self</code>  <code>classmethod</code>","text":"<p>Decode the message (command ID only, no data expected for this message).</p>"},{"location":"api/messages/#pykmp.messages.GetSerialRequest.encode","title":"<code>encode() -&gt; codec.ApplicationData</code>","text":"<p>Encode the message (command ID only, no data expected for this message).</p>"},{"location":"api/messages/#pykmp.messages.GetSerialResponse","title":"<code>pykmp.messages.GetSerialResponse</code>","text":"<p>             Bases: <code>BaseResponse[GetSerialRequest]</code>, <code>WithDataMixin</code>, <code>SupportsDecode</code>, <code>SupportsEncode</code></p> <p>Response with the serial number of the meter.</p>"},{"location":"api/messages/#pykmp.messages.GetSerialResponse.data_raw","title":"<code>data_raw: codec.ApplicationDataBytes | None = attrs.field(default=None)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/messages/#pykmp.messages.GetSerialResponse.request_type","title":"<code>request_type: type</code>  <code>class-attribute</code>","text":""},{"location":"api/messages/#pykmp.messages.GetSerialResponse.command_id","title":"<code>command_id: int = GetSerialRequest.command_id</code>  <code>class-attribute</code>","text":""},{"location":"api/messages/#pykmp.messages.GetSerialResponse.command_name","title":"<code>command_name: str = GetSerialRequest.command_name</code>  <code>class-attribute</code>","text":""},{"location":"api/messages/#pykmp.messages.GetSerialResponse.serial","title":"<code>serial: str = attrs.field()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/messages/#pykmp.messages.GetSerialResponse.SERIAL_LENGTH_ENCODED","title":"<code>SERIAL_LENGTH_ENCODED: int = 4</code>  <code>class-attribute</code>","text":""},{"location":"api/messages/#pykmp.messages.GetSerialResponse.SERIAL_VALUE_MAX","title":"<code>SERIAL_VALUE_MAX: int = 2 ** SERIAL_LENGTH_ENCODED * 8 - 1</code>  <code>class-attribute</code>","text":""},{"location":"api/messages/#pykmp.messages.GetSerialResponse.get_request_type","title":"<code>get_request_type() -&gt; type[Req_t_co]</code>  <code>classmethod</code>","text":"<p>Return the request class (type) matching this response class.</p>"},{"location":"api/messages/#pykmp.messages.GetSerialResponse.digits_only_validator","title":"<code>digits_only_validator(_: attrs.Attribute[Self], value: str) -&gt; None</code>","text":"<p>Validate all characters in string of serial number are digits.</p>"},{"location":"api/messages/#pykmp.messages.GetSerialResponse.decode","title":"<code>decode(data: codec.ApplicationData) -&gt; Self</code>  <code>classmethod</code>","text":"<p>Decode GetSerialNo response.</p>"},{"location":"api/messages/#pykmp.messages.GetSerialResponse.encode","title":"<code>encode() -&gt; codec.ApplicationData</code>","text":"<p>Encode GetSerialNo response.</p>"},{"location":"api/messages/#pykmp.messages.GetRegisterRequest","title":"<code>pykmp.messages.GetRegisterRequest</code>","text":"<p>             Bases: <code>BaseRequest['GetRegisterResponse']</code>, <code>WithDataMixin</code>, <code>SupportsDecode</code>, <code>SupportsEncode</code></p> <p>Request register values.</p>"},{"location":"api/messages/#pykmp.messages.GetRegisterRequest.data_raw","title":"<code>data_raw: codec.ApplicationDataBytes | None = attrs.field(default=None)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/messages/#pykmp.messages.GetRegisterRequest.response_type","title":"<code>response_type: type[GetRegisterResponse]</code>  <code>class-attribute</code>","text":""},{"location":"api/messages/#pykmp.messages.GetRegisterRequest.command_id","title":"<code>command_id: int = constants.CommandId.GET_REGISTER.value</code>  <code>class-attribute</code>","text":""},{"location":"api/messages/#pykmp.messages.GetRegisterRequest.command_name","title":"<code>command_name: str = 'GetRegister'</code>  <code>class-attribute</code>","text":""},{"location":"api/messages/#pykmp.messages.GetRegisterRequest.registers","title":"<code>registers: Collection[RegisterID] = attrs.field(converter=_ints2register_ids)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/messages/#pykmp.messages.GetRegisterRequest.NUM_REGISTERS_LENGTH_ENCODED","title":"<code>NUM_REGISTERS_LENGTH_ENCODED: int = 1</code>  <code>class-attribute</code>","text":""},{"location":"api/messages/#pykmp.messages.GetRegisterRequest.NUM_REGISTERS_MAX","title":"<code>NUM_REGISTERS_MAX: int = 8</code>  <code>class-attribute</code>","text":""},{"location":"api/messages/#pykmp.messages.GetRegisterRequest.REGISTER_ID_LENGTH_ENCODED","title":"<code>REGISTER_ID_LENGTH_ENCODED: int = 2</code>  <code>class-attribute</code>","text":""},{"location":"api/messages/#pykmp.messages.GetRegisterRequest.REGISTER_ID_VALUE_MAX","title":"<code>REGISTER_ID_VALUE_MAX: int = 2 ** REGISTER_ID_LENGTH_ENCODED * 8 - 1</code>  <code>class-attribute</code>","text":""},{"location":"api/messages/#pykmp.messages.GetRegisterRequest.get_response_type","title":"<code>get_response_type() -&gt; type[Res_t_co]</code>  <code>classmethod</code>","text":"<p>Return the response class (type) matching this request class.</p>"},{"location":"api/messages/#pykmp.messages.GetRegisterRequest.register_id_validator","title":"<code>register_id_validator(_: attrs.Attribute[Self], value: Collection[RegisterID]) -&gt; None</code>","text":"<p>Validate all register IDs in collection requested are within valid range.</p>"},{"location":"api/messages/#pykmp.messages.GetRegisterRequest.decode","title":"<code>decode(data: codec.ApplicationData) -&gt; Self</code>  <code>classmethod</code>","text":"<p>Decode GetRegister request.</p>"},{"location":"api/messages/#pykmp.messages.GetRegisterRequest.encode","title":"<code>encode() -&gt; codec.ApplicationData</code>","text":"<p>Encode GetRegister request.</p>"},{"location":"api/messages/#pykmp.messages.GetRegisterResponse","title":"<code>pykmp.messages.GetRegisterResponse</code>","text":"<p>             Bases: <code>BaseResponse[GetRegisterRequest]</code>, <code>WithDataMixin</code>, <code>SupportsDecode</code>, <code>SupportsEncode</code></p> <p>Response with register value(s).</p>"},{"location":"api/messages/#pykmp.messages.GetRegisterResponse.data_raw","title":"<code>data_raw: codec.ApplicationDataBytes | None = attrs.field(default=None)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/messages/#pykmp.messages.GetRegisterResponse.request_type","title":"<code>request_type: type = GetRegisterRequest</code>  <code>class-attribute</code>","text":""},{"location":"api/messages/#pykmp.messages.GetRegisterResponse.command_id","title":"<code>command_id: int = GetRegisterRequest.command_id</code>  <code>class-attribute</code>","text":""},{"location":"api/messages/#pykmp.messages.GetRegisterResponse.command_name","title":"<code>command_name: str = GetRegisterRequest.command_name</code>  <code>class-attribute</code>","text":""},{"location":"api/messages/#pykmp.messages.GetRegisterResponse.registers","title":"<code>registers: Mapping[RegisterID, RegisterData] = attrs.field(factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/messages/#pykmp.messages.GetRegisterResponse.REGISTER_ID_LENGTH_ENCODED","title":"<code>REGISTER_ID_LENGTH_ENCODED: int = 2</code>  <code>class-attribute</code>","text":""},{"location":"api/messages/#pykmp.messages.GetRegisterResponse.REGISTER_UNIT_LENGTH_ENCODED","title":"<code>REGISTER_UNIT_LENGTH_ENCODED: int = 1</code>  <code>class-attribute</code>","text":""},{"location":"api/messages/#pykmp.messages.GetRegisterResponse.REGISTER_VALUE_LENGTH_LENGTH_ENCODED","title":"<code>REGISTER_VALUE_LENGTH_LENGTH_ENCODED: int = 1</code>  <code>class-attribute</code>","text":""},{"location":"api/messages/#pykmp.messages.GetRegisterResponse.REGISTER_VALUE_FORMAT_LENGTH_ENCODED","title":"<code>REGISTER_VALUE_FORMAT_LENGTH_ENCODED: int = 1</code>  <code>class-attribute</code>","text":""},{"location":"api/messages/#pykmp.messages.GetRegisterResponse.get_request_type","title":"<code>get_request_type() -&gt; type[Req_t_co]</code>  <code>classmethod</code>","text":"<p>Return the request class (type) matching this response class.</p>"},{"location":"api/messages/#pykmp.messages.GetRegisterResponse.decode","title":"<code>decode(data: codec.ApplicationData) -&gt; Self</code>  <code>classmethod</code>","text":"<p>Decode the GetRegister response.</p>"},{"location":"api/messages/#pykmp.messages.GetRegisterResponse.encode","title":"<code>encode() -&gt; codec.ApplicationData</code>","text":"<p>Encode the GetRegister response.</p>"},{"location":"api/messages/#data-classes-types","title":"Data classes &amp; types","text":""},{"location":"api/messages/#pykmp.messages.RegisterData","title":"<code>pykmp.messages.RegisterData</code>","text":"<p>Partially decoded register data.</p>"},{"location":"api/messages/#pykmp.messages.RegisterData.id_","title":"<code>id_: RegisterID</code>  <code>instance-attribute</code>","text":""},{"location":"api/messages/#pykmp.messages.RegisterData.unit","title":"<code>unit: RegisterUnit</code>  <code>instance-attribute</code>","text":""},{"location":"api/messages/#pykmp.messages.RegisterData.value","title":"<code>value: RegisterValueBytes</code>  <code>instance-attribute</code>","text":""},{"location":"api/messages/#pykmp.messages.RegisterID","title":"<code>pykmp.messages.RegisterID = NewType('RegisterID', int)</code>  <code>module-attribute</code>","text":""},{"location":"api/messages/#pykmp.messages.RegisterUnit","title":"<code>pykmp.messages.RegisterUnit = NewType('RegisterUnit', int)</code>  <code>module-attribute</code>","text":""},{"location":"api/messages/#pykmp.messages.RegisterValueBytes","title":"<code>pykmp.messages.RegisterValueBytes = NewType('RegisterValueBytes', bytes)</code>  <code>module-attribute</code>","text":""},{"location":"api/messages/#pykmp.messages.Req_t_co","title":"<code>pykmp.messages.Req_t_co = TypeVar('Req_t_co', bound='BaseRequest[Any]', covariant=True)</code>  <code>module-attribute</code>","text":""},{"location":"api/messages/#pykmp.messages.Res_t_co","title":"<code>pykmp.messages.Res_t_co = TypeVar('Res_t_co', bound='BaseResponse[Any]', covariant=True)</code>  <code>module-attribute</code>","text":""},{"location":"api/messages/#base-classes","title":"Base classes","text":""},{"location":"api/messages/#pykmp.messages.HasCommandIdAndName","title":"<code>pykmp.messages.HasCommandIdAndName</code>","text":"<p>             Bases: <code>Protocol</code></p>"},{"location":"api/messages/#pykmp.messages.HasCommandIdAndName.command_id","title":"<code>command_id: int</code>  <code>class-attribute</code>","text":""},{"location":"api/messages/#pykmp.messages.HasCommandIdAndName.command_name","title":"<code>command_name: str</code>  <code>class-attribute</code>","text":""},{"location":"api/messages/#pykmp.messages.BaseRequest","title":"<code>pykmp.messages.BaseRequest</code>","text":"<p>             Bases: <code>HasCommandIdAndName</code>, <code>Protocol[Res_t_co]</code></p> <p>Base protocol for any message that is a request (client to meter).</p> <p>Generically type-annotated for the response type matching the request.</p>"},{"location":"api/messages/#pykmp.messages.BaseRequest.command_id","title":"<code>command_id: int</code>  <code>class-attribute</code>","text":""},{"location":"api/messages/#pykmp.messages.BaseRequest.command_name","title":"<code>command_name: str</code>  <code>class-attribute</code>","text":""},{"location":"api/messages/#pykmp.messages.BaseRequest.response_type","title":"<code>response_type: type</code>  <code>class-attribute</code>","text":""},{"location":"api/messages/#pykmp.messages.BaseRequest.get_response_type","title":"<code>get_response_type() -&gt; type[Res_t_co]</code>  <code>classmethod</code>","text":"<p>Return the response class (type) matching this request class.</p>"},{"location":"api/messages/#pykmp.messages.BaseResponse","title":"<code>pykmp.messages.BaseResponse</code>","text":"<p>             Bases: <code>HasCommandIdAndName</code>, <code>Protocol[Req_t_co]</code></p> <p>Base protocol for any message that is a response (meter to client).</p> <p>Generically type-annotated for the request type matching the response.</p>"},{"location":"api/messages/#pykmp.messages.BaseResponse.command_id","title":"<code>command_id: int</code>  <code>class-attribute</code>","text":""},{"location":"api/messages/#pykmp.messages.BaseResponse.command_name","title":"<code>command_name: str</code>  <code>class-attribute</code>","text":""},{"location":"api/messages/#pykmp.messages.BaseResponse.request_type","title":"<code>request_type: type</code>  <code>class-attribute</code>","text":""},{"location":"api/messages/#pykmp.messages.BaseResponse.get_request_type","title":"<code>get_request_type() -&gt; type[Req_t_co]</code>  <code>classmethod</code>","text":"<p>Return the request class (type) matching this response class.</p>"},{"location":"api/messages/#pykmp.messages.SupportsDecode","title":"<code>pykmp.messages.SupportsDecode</code>","text":"<p>             Bases: <code>Protocol</code></p> <p>Base protocol to indicate it supports decoding (has decode() class method).</p>"},{"location":"api/messages/#pykmp.messages.SupportsDecode.decode","title":"<code>decode(data: codec.ApplicationData) -&gt; Self</code>  <code>classmethod</code>","text":"<p>Decode application data to structured message instance (of type itself).</p>"},{"location":"api/messages/#pykmp.messages.SupportsEncode","title":"<code>pykmp.messages.SupportsEncode</code>","text":"<p>             Bases: <code>Protocol</code></p> <p>Base protocol to indicate it supports encoding (has encode() class method).</p>"},{"location":"api/messages/#pykmp.messages.SupportsEncode.encode","title":"<code>encode() -&gt; codec.ApplicationData</code>","text":"<p>Encode itself (structured message instance) to application data.</p>"},{"location":"api/messages/#pykmp.messages.WithDataMixin","title":"<code>pykmp.messages.WithDataMixin</code>","text":"<p>             Bases: <code>HasCommandIdAndName</code>, <code>Protocol</code></p> <p>Protocol with 'data_raw' attribute to reference the pre-decoded original data.</p>"},{"location":"api/messages/#pykmp.messages.WithDataMixin.command_id","title":"<code>command_id: int</code>  <code>class-attribute</code>","text":""},{"location":"api/messages/#pykmp.messages.WithDataMixin.command_name","title":"<code>command_name: str</code>  <code>class-attribute</code>","text":""},{"location":"api/messages/#pykmp.messages.WithDataMixin.data_raw","title":"<code>data_raw: codec.ApplicationDataBytes | None = attrs.field(default=None)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/messages/#exceptions","title":"Exceptions","text":""},{"location":"api/messages/#pykmp.messages.MessageCidMismatchError","title":"<code>pykmp.messages.MessageCidMismatchError</code>","text":"<p>             Bases: <code>BaseCodecError</code></p> <p>Command ID in data does not match the ID defined for the class to decode to.</p>"},{"location":"api/messages/#pykmp.messages.MessageCidMismatchError.message_class_name","title":"<code>message_class_name: str</code>  <code>instance-attribute</code>","text":""},{"location":"api/messages/#pykmp.messages.MessageCidMismatchError.cid_expected","title":"<code>cid_expected: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/messages/#pykmp.messages.MessageCidMismatchError.actual","title":"<code>actual: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/messages/#pykmp.messages.MessageCidMismatchError.__str__","title":"<code>__str__() -&gt; str</code>","text":""},{"location":"api/messages/#pykmp.messages.DataWithNoDataError","title":"<code>pykmp.messages.DataWithNoDataError</code>","text":"<p>             Bases: <code>BaseCodecError</code></p> <p>Unexpected data for command that does not accept any (aside the command ID).</p>"},{"location":"api/messages/#pykmp.messages.DataWithNoDataError.message_class","title":"<code>message_class: type[HasCommandIdAndName]</code>  <code>instance-attribute</code>","text":""},{"location":"api/messages/#pykmp.messages.DataWithNoDataError.__str__","title":"<code>__str__() -&gt; str</code>","text":""},{"location":"api/messages/#pykmp.messages.SoftwareRevisionInvalidError","title":"<code>pykmp.messages.SoftwareRevisionInvalidError</code>","text":"<p>             Bases: <code>BaseCodecError</code></p>"},{"location":"api/messages/#pykmp.messages.SoftwareRevisionInvalidError.revision_string","title":"<code>revision_string: str</code>  <code>instance-attribute</code>","text":""},{"location":"api/messages/#pykmp.messages.SoftwareRevisionInvalidError.__str__","title":"<code>__str__() -&gt; str</code>","text":""},{"location":"api/messages/#pykmp.messages.SerialNumberInvalidError","title":"<code>pykmp.messages.SerialNumberInvalidError</code>","text":"<p>             Bases: <code>BaseCodecError</code></p>"},{"location":"api/messages/#pykmp.messages.SerialNumberInvalidError.serial","title":"<code>serial: str</code>  <code>instance-attribute</code>","text":""},{"location":"api/messages/#pykmp.messages.SerialNumberInvalidError.__str__","title":"<code>__str__() -&gt; str</code>","text":""}]}